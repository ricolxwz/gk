---
title: Database:Transaction
comments: true
---

## ACID

- Atomicity: A transaction is either performed entirely or not performed at all
- Consistency: 
    - All database constraints are satisfied
    - The new database state satisfies the specification of the transaction
- Isolation: Effect of multiple transaction running concurrently, the effect of the execution is such that it is as if they are running sequentially
- Durability: Once the transactions are committed, they must be persist even if there is a system failure

### Isolation

#### Interface Issues

- Lost update: A: 100, B: 200, the value is overwitten by B
- Temporary update: A: 100 -> 50 (rollback), B is unaware of this change, still read 100
- Incorrect summary problem: A is updating an aggregation of records while B is writing some part of the records

#### Level

- Read uncommitted: A transaction can read data written by a concurrent uncommitted
transaction. This is a called a dirty read
- Read committed: The database will not read any of the uncommitted values, i.e., no
dirty reads
- Repeatable read: A transaction only sees data committed before the transaction began; It never sees either uncommitted data or changes committed by concurrent transactions while it is executing
- Setializable: Highest level of isolation - serializable execution is defined to be an execution of the operations of concurrently executing transactions that produce the same effect as some serial execution of those same transactions

#### Conflict

- Read-Read conflict
- Read-Write conflict
- Write-Write conflict

##### Conflict Equivalent

Two schedules are said to be conflict equivalent when one can be transformed to another by swapping non-conflicting operations. 

#### Schedule

- Serial/Nonserial schedule: A serial scheduel is a schedule in which all transactions are executed from start to finish, without any interleaving
- Serializable/Nonserializable schedule: If a schedule is identical to one serial schedule, then it's serializable

##### Conflict Serializability

A schedule is conflict serializable if it is confliect equivalent to some serial schedule.

###### How to Check?

Use precedence graph! 

- Every transaction is considered as a node
- Asume I from transaction 1 and J from transaction 2 conflicts, then if I is executed before J, then there is a edge from 1 to 2

If the final graph is acyclic, then it's conflict serializable.