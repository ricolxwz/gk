---
title: 数据库:规范化
comments: true
---

## 冗余 [^1]

数据冗余指的是在数据库中存在重复存储相同信息的情况. 这可能是因为设计不当, 数据合并或者操作错误等原因造成的. 虽然在某些情况下数据冗余可能有正面作用, 比如数据备份和恢复. 但是大部分时候, 它会造成存储空间浪费, 增加数据管理的复杂性, 并可能引发数据一致性问题.

### 影响 [^1]

数据冗余最直接的影响就是浪费存储空间. 在一个包含冗余数据的系统中, 相同的信息会被多次存储. 这种冗余占用了大量的存储空间, 尤其对于大规模数据集来说, 这种空间浪费是显著的.

其次, 在有冗余数据的系统中, 保持数据的一致性是一个重要的挑战. 如果不同的副本之间没有正确地同步, 那么就可能产生不一致的数据, 从而影响到依赖这些数据的决策和操作.

最后, 冗余数据会使数据管理变得复杂, 为了保持数据的一致性, 当某个数据项需要更新的时候, 所有包含则个数据项的地方都需要更新, 这增加了数据维护的工作量和出错的可能性.

#### 异常

以[学生选课表为例](https://img.ricolxwz.io/9284796b69eedeeebe319e75c18049a9.png), 数据冗余可能会导致三种异常:

- 更新异常: 如果该门课程的房间号发生了变化, 例如从"R101"改为"R203", 那么所有与此房间关联的记录都要进行更新, 如果遗漏了某条记录, 会导致数据不一致的情况, 即更新异常
- 删除异常: 如果所有的学生都退选了这个课程, 那么该课程的房间信息就会被删除, 因为它是和学生记录一起存储的, 这样就会导致丢失该课程的房间信息, 即删除异常
- 插入异常: 如果我们想为某个课程预定一个房间, 但是还没有任何学生选修这个课程, 我们无法单独存储房间信息, 因为房间信息依赖于学生-课程关联, 即插入异常

### 好坏数据库设计

坏的数据库设计常常:

- 还有冗余(浪费磁盘空间)
- 导致更新, 删除, 插入异常

好的数据库设计常常:

- 最小的冗余
- 没有更新, 删除, 插入异常

### 解决方法

规范化设计过程以避免异常. 规范化, Normalization是定义什么是好的关系型设计的过程. 其主要目的是解决数据库中的更新, 插入, 删除等操作时可能出现的异常, 避免不好的设计, 改善数据库的结构. 在了解规范化之前需要了解[函数依赖](#函数依赖), 因为它是规范化的核心工具.

## 函数依赖 {#函数依赖}

函数依赖, Functional Dependencies, 用来捕捉属性之间的语义关系, 检测消除不良设计, 识别冗余数据. 其非正式的定义为属性X的值决定了属性Y的值. 例如每一门课都只会在一个教室上, COMP9120只会在R101房间上, 这里课程决定了房间号. 其正式的定义为: 假设X和Y是两组属性, X和Y之间的关系可以用一个函数来表示, 它的本质是, X的一个值不能映射到多个Y的值, 这意味着X和Y之间的关系是n对1或1对1的关系. 如UoS->Room.

### 确定函数依赖

那么, 我们如何确定该函数依赖呢? 或者说, 如何发现函数依赖呢? 

主要通过两种方式:

- 考虑属性的语义
- 分析表中的实际数据

在大多数情况下, 我们使用语义来判断函数依赖. 当使用数据来确定函数依赖的过程又被称为知识挖掘, knowledge mining. 如[图](https://img.ricolxwz.io/be0f5b8161ff4bbd9b178cead0c599ac.png). 从数据可以大致判断, 分行的名称和城市之间有一个函数依赖, 贷款编号和客户名称/数量之间有一个函数依赖, 贷款编号和分行名称之间有一个函数依赖, 城市和资产之间有一个函数依赖, 但是, 这样确定依赖不是特别靠谱, 请见下方注意.

???+ warning "注意"

    我们可以通过查看表中的某个实例, 来判断函数依赖不成立. 但是, 我们无法通过观察任何数量的实例, 推断出某个函数依赖成立. 这是因为函数依赖是关于所有可能的合法实例的声明, 不仅仅基于当前看到的某些实例. 因此, 仅凭部分数据或者实例, 无法确定函数依赖在所有情况下都成立, 需要更加广泛的验证.

#### Armstrong公理

Armstrong公理是函数依赖推理规则的基础, 它主要包含三个公理.

- 自反性: reflexivity, 如果B ⊆ A, A → B; 当右侧的属性出现在左侧, 那么称之为一个平凡函数依赖; 例如cpoints, uos_name → uos_name, 因为uos_name已经出现在左侧
- 增广性: augentation, 如果A → B, 那么对于任何属性集C, AC → BC; 例如cpoints → wload推导出cpoints, uos_name → wload, uos_name, 即在两侧同时增加uos_name
- 传递性: transitivity, 如果A → B且B → C, 那么A → C; 例如uos_code → cpoints和cpoints → wload推导出uos_code → wload

???+ example "例子"

    给定下列表:

    | Name   | Color | Category | Dept   | Price |
    |--------|-------|----------|--------|-------|
    | Gizmo  | Green | Gadget   | Toys   | 49    |
    | Widget | Black | Gadget   | Toys   | 59    |
    | Gizmo  | Green | Whatsit  | Garden | 99    |

    已知的函数依赖:

    - Name → Color
    - Category → Dept
    - Color, Category → Price

    根据给出的函数依赖, 我们推断Name, Category → Price对于所有的实例都成立, 现在利用Armstrong公理证明.

    1. 根据增广性, 有Name, Category → Color, Category
    2. 根据传递性, Color, Category → Price, 所以Name, Category → Price

Armstrong公理具有:

- 健全性: 当将其应用于函数依赖集F的时候, 只会生成在F+中的有效函数依赖
- 完备性: 通过反复应用公理, 可以生成闭包F+中的所有函数依赖
    
##### 附加规则

基于Armstrong公理还能导出一些附加规则. 

- 分解: decomposition, 如果A → BC, 那么可以推导出A → B和A → C
- 联合: union, 如果A → B且A → C, 则可以推导出A → BC

### 闭包

能从函数依赖集F中推导出的所有函数依赖组成的集合, 成为F的闭包. 计算闭包方法如下:

1. 初始化: 设定初始闭包F+=F, 也就是闭包开始的时候等于原始的函数依赖集F
2. 循环迭代:
    1. 对于闭包F+中的每个函数依赖FD, 应用自反性和增广性规则, 推导出新的函数依赖, 将新推导出的函数依赖加入到F+中
    2. 对于闭包F+中的每一对函数依赖F1和F2, 如果F1和F2可以通过传递性规则组合成新的函数依赖, 将结果加入到F+中
3. 停止条件: 当闭包F+不再发生变化的时候, 算法终止

在最坏情况下, 函数闭包会随着F中属性数量的增加而呈现指数级增长, 这意味着计算F+在某些情况下可能会非常耗时, 下面是一个简单的例子.

???+ example "例子"

    假设我们在关系R中有三个属性A, B, C. 已知的函数依赖集F为F={A → B, B → C}. 可以计算出F+如[图](https://img.ricolxwz.io/b21b9f5c8611d9361bbd42a5902009a8.png)所示.

[^1]: 数据冗余（data redundant）现象介绍-CSDN博客. (n.d.). Retrieved September 26, 2024, from https://blog.csdn.net/Dontla/article/details/134932405